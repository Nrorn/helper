!-!-!-!-!-!-!!-!-!-!-!-!-!
протокол jdbc в python для получения доступа к БД
!-!-!-!-!-!-!!-!-!-!-!-!-!

для выполения bash скриптов в python нужно прибегнуть к следующей конструкции

output="$(dmesg | grep sda)"
Чтобы воссоздать подобное поведение с помощью модуля subprocess без установки параметра shell в значение True, как мы видели ранее, мы должны напрямую использовать класс Popen:


dmesg = subprocess.Popen(['dmesg'], stdout=subprocess.PIPE)
grep = subprocess.Popen(['grep', 'sda'], stdin=dmesg.stdout)
dmesg.stdout.close()
output = grep.comunicate()[0]

Рассматривая данный пример, вы должны помнить, что процесс, запущенный с использованием класса Popen, не блокирует выполнение скрипта.

Первое, что мы сделали в приведенном выше фрагменте кода, — это создали объект Popen, представляющий процесс dmesg. Мы установили stdout этого процесса на subprocess.PIPE. Данное значение указывает, что пайп к указанному потоку должен быть открыт.

Затем мы создали еще один экземпляр класса Popen для процесса grep. В конструкторе Popen мы, конечно, указали команду и ее аргументы, но вот что важно, мы установили стандартный вывод процесса dmesg в качестве стандартного ввода для grep (stdin=dmesg.stdout), чтобы воссоздать поведение конвейера оболочки.

После создания объекта Popen для команды grep мы закрыли поток stdout процесса dmesg, используя метод close(). Это, как указано в документации, необходимо для того, чтобы первый процесс мог получить сигнал SIGPIPE. Дело в том, что обычно, когда два процесса соединены конвейером, если один справа от «|» (grep в нашем примере) завершается раньше, чем тот, что слева (dmesg), то последний получает сигнал SIGPIPE (пайп закрыт) и по умолчанию тоже заканчивает свою работу.

Однако при репликации пайплайна между двумя командами в Python возникает проблема. stdout первого процесса открывается как в родительском скрипте, так и в стандартном вводе другого процесса. Таким образом, даже если процесс grep завершится, пайп останется открытым в вызывающем процессе (нашем скрипте), поэтому dmesg никогда не получит сигнал SIGPIPE. Вот почему нам нужно закрыть поток stdout первого процесса в нашем основном скрипте после запуска второго.

Последнее, что мы сделали, — это вызвали метод communicate() объекта grep. Этот метод можно использовать для необязательной передачи данных в stdin процесса. Он ожидает завершения процесса и возвращает кортеж. Где первый элемент — это stdout (на который ссылается переменная output), а второй — stderr процесса.


=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Как видите, переменная $HOME не была заменена на соответствующее значение. Такой способ выполнения процессов является рекомендованным, так как позволяет избежать потенциальные угрозы безопасности. Однако, в некоторых случаях, когда нам нужно вызвать оболочку в качестве промежуточного процесса, достаточно установить для параметра shell функции run значение True. В таких случаях желательно указать команду и ее аргументы в виде строки:

>>> process = subprocess.run('ls -al $HOME', shell=True)


=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


str.starts	ith(prefix[, start[, end]])
Параметры:
prefix - объект поддерживающий итерацию (кортеж, символ или подстрока).
start - int, индекс начала поиска, по умолчанию 0, необязательно.
end - int, индекс конца поиска, по умолчанию len(str), необязательно.

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
проверить версию питона
python --version

Способ запуска файла Python в командной строке выглядит следующим образом:

python3 helloworld.py	

!-!-!-!-!-!-!!-!-!-!-!-!-!
Python - динамически типизированный язык, и это не нужно указывать типы переменных, которые вы используете, и переменные не привязаны к конкретному типу.
!-!-!-!-!-!-!!-!-!-!-!-!-!

Основы

1. Переменные

# booleans (булевые значения)
true_boolean = True
false_boolean = False
 
# string (строка)
my_name = "Leandro Tk"

# float (числа с плавающей запятой)
book_price = 15.80	

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=

2. Поток управления: условные операторы

if использует выражение для оценки того, является ли утверждение истинным или ложным. Если это True, он выполняет то, что находится внутри оператора if. Например:

if True:
  print("Hello Python If")

if 2 > 1:
  print("2 is greater than 1")	
  
  
2 больше 1, поэтому выполняется код print. Оператор else будет выполнен, если выражение if ложно.

Функция print () выводит указанное сообщение на экран.
if 1 > 2:
  print("1 is greater than 2")
else:
  print("1 is not greater than 2")	  
  
if 1 > 2:
  print("1 is greater than 2")
elif 2 > 1:
  print("1 is not greater than 2")
else:
  print("1 is equal to 2")

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=
  	
3. Цикл / Итератор

Цикл while: пока оператор имеет значение True, код внутри блока будет выполнен. Итак, этот код напечатает число от 1 до 10.

num = 1
while num <= 10:
    print(num)
    num += 1
Циклу while требуется «условие цикла». Если он остается True, он продолжает повторение. В этом примере, когда num равно 11, условие цикла равно False.	

Еще один базовый фрагмент кода, чтобы лучше его понять:

loop_condition = True
while loop_condition:
    print("Loop Condition keeps: %s" %(loop_condition))
    loop_condition = False
Условие цикла мы записали в переменную loop_condition, которая равна True, поэтому повторение продолжается до тех пор, пока мы не установим для него значение false.    


Цикл for: вы применяете переменную num к блоку, и оператор for выполнит итерацию для вас. Этот код будет напечатан так же, как и код while: от 1 до 10.

for i in range(1, 11):
  print(i)	
Видите? Это так просто. Диапазон начинается с 1 и продолжается до 11-го элемента (10 - 10-й элемент).

!-!-!-!-!-!-!!-!-!-!-!-!-!
range -указываем диапазон откуда до укуда будем выполнять 
!-!-!-!-!-!-!!-!-!-!-!-!-!

truba=1
rtuba=15
for i in range(truba, rtuba):
  print(i)



=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
List: коллекция, массив, cтруктура данных
Представьте, что вы хотите сохранить целое число 1 в переменной. Но, может быть, теперь вы захотите сохранить 2. И 3, 4, 5…

List - это список или коллекция, которую можно использовать для хранения списка значений (например, этих целых чисел, которые вы хотите). Итак, давайте воспользуемся этим:

my_integers = [1, 2, 3, 4, 5]	
Это действительно просто. Мы создали массив и сохранили его в my_integer.

Чтобы было понятнее, мы можем представить массив и каждый элемент с его индексом.

Array: [5][7][1][3][4]	
Index: [0][1][2][3][4]	
Используя синтаксис Python, также просто понять:

my_integers = [5, 7, 1, 3, 4]
print(my_integers[0]) # 5
print(my_integers[1]) # 7
print(my_integers[4]) # 4	

Представьте, что вы не хотите хранить целые числа. Вы просто хотите хранить строки, например, список имен. Он бы выглядел примерно так:

relatives_names = [
  "Alex",
  "Juliana",
  "Max",
  "Bruno",
  "Kaio"
]

print(relatives_names[4]) # Kaio

как мы можем добавить элемент в структуру данных List (элемент в список).

Самый распространенный метод добавления нового значения в List - это append. Посмотрим, как это работает:

bookshelf = []
bookshelf.append("The Effective Engineer")
bookshelf.append("The 4 Hour Work Week")
print(bookshelf[0]) # The Effective Engineer
print(bookshelf[1]) # The 4 Hour Work Week	
append делать очень просто. Вам просто нужно применить элемент (например, «The Effective Engineer») в качестве параметра добавления.

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=
Dictionary: структура данных "ключ-значение"(ассацитивный масив)

Давайте узнаем о структуре данных Dictionary или Словари на русском. Dictionary - это набор пар ключ-значение. Вот как это выглядит:
dictionary_example = {
  "key1": "value1",
  "key2": "value2",
  "key3": "value3"
}
!-!-!-!-!-!-!!-!-!-!-!-!-!
Dictionary иногда ещё называют ассоциативными массивами или хеш-таблицами.
!-!-!-!-!-!-!!-!-!-!-!-!-!

Ключ key - это индекс, указывающий на значение value. Как нам получить доступ к значению словаря? Вы догадались - с помощью ключа. Давай попробуем:

dictionary_tk = {
  "name": "Leandro",
  "nickname": "Tk",
  "birthplace": "Brazil"
}

print("My name is %s" %(dictionary_tk["name"])) # My name is Leandro
print("But you can call me %s" %(dictionary_tk["nickname"])) # But you can call me Tk
print("And by the way I'm from %s" %(dictionary_tk["birthplace"])) # And by the way I'm from Brazil


Еще одна замечательная вещь в Dictionary - это то, что мы можем использовать что угодно в качестве значения. Допустим что в созданном словаре мы хотим добавить в него ключ age и записать туда настоящий целочисленный возраст:

dictionary_tk = {
  "name": "Leandro",
  "nickname": "Tk",
  "birthplace": "Brazil"
  "age": 24
}

print("My name is %s" %(dictionary_tk["name"])) # My name is Leandro
print("But you can call me %s" %(dictionary_tk["nickname"])) # But you can call me Tk
print("And by the way I'm from %s" %(dictionary_tk["birthplace"])) # And by the way I'm from Brazil
Здесь у нас есть пара ключ: age, значение: 24, использующая строку в качестве ключа и целое число в качестве значения.


Как и в случае со списками, давайте узнаем, как добавлять элементы в словарь. Ключ, указывающий на значение, - это большая часть того, что такое Dictionary. Это также верно, когда мы говорим о добавлении к нему элементов:

dictionary_tk = {
  "name": "Leandro",
  "nickname": "Tk",
  "birthplace": "Brazil"
}

dictionary_tk['age'] = 24

print(dictionary_tk) # {'birthplace': 'Brazil', 'age': 24, 'nickname': 'Tk', 'name': 'Leandro'}	


!-!-!-!-!-!-!!-!-!-!-!-!-!
Также в Pythhon есть другие типы данных - кортежи (tuple), который по сути является неизменяемым списком и множества (set), содержащий не повторяющиеся элементы в случайном порядке.
!-!-!-!-!-!-!!-!-!-!-!-!-!

Кортежи (tuple)
По своей природе они очень схожи со списками, но, в отличие от последних, являются неизменяемыми.
https://pythonchik.ru/osnovy/kortezhi-v-python
# кортеж
immutable_tuple = (4, 5, 6)
immutable_tuple[0] = 404
 
> 
Traceback (most recent call last):
  immutable_tuple[0] = 404
TypeError: 'tuple' object does not support item assignment

# список
mutable_list = [7, 8, 9]
mutable_list[0] = 1
print(mutable_list)
 
> [1, 8, 9]

Примеры кортежей

# пустой кортеж
empty_tuple = ()
 
# кортеж из 4-х элементов разных типов
four_el_tuple = (36.6, 'Normal', None, False)
 
# пример tuple, что содержит вложенные элементы
nested_elem_tuple = (('one', 'two'), ['three', 'four'], {'five': 'six'}, (('seven', 'eight'), ('nine', 'ten')))
print(nested_elem_tuple)
 
> (('one', 'two'), ['three', 'four'], {'five': 'six'}, (('seven', 'eight'), ('nine', 'ten')))

приищущества картежей перед списком
*Кортеж защищен от изменений, как намеренных(что плохо), так и случайныз (что хорошо )
* Меньший размер
>>> a=(1,2,3,4,5)
>>> b=[1,2,3,4,5]
>>> a._sizeof__()
36
>>> b._sizeof__()


Работа с кортежами
Создание Как и другие коллекции языка Питон, кортеж можно создать двумя способами.

Способ №1: Литеральное объявление:

literal_creation = ('any', 'object')

print(literal_creation)
> ('any', 'object')
 
print(type(literal_creation))
> <class 'tuple'>

Способ №2: Через функцию 
tuple()
:

tuple_creation = tuple('any iterable object')

print(tuple_creation)
> ('a', 'n', 'y', ' ', 'i', 't', 'e', 'r', 'a', 'b', 'l', 'e', ' ', 'o', 'b', 'j', 'e', 'c', 't')
 
print(type(tuple_creation))
> <class 'tuple'>


=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=
Множества (set)
https://python-scripts.com/sets
Множества в Python – это структура данных, которые содержат неупорядоченные элементы. Элементы также не является индексированным. Как и список, множество позволяет внесение и удаление элементов. Однако, есть ряд особенных характеристик, которые определяют и отделяют множество от других структур данных:

Множество не содержит дубликаты элементов;
Элементы множества являются неизменными (их нельзя менять), однако само по себе множество является изменяемым, и его можно менять;
Так как элементы не индексируются, множества не поддерживают никаких операций среза и индексирования.

Мы можем создать множество путем передачи всех элементов множества внутри фигурных скобок {} и разделить элементы при помощи запятых (,). Множество может содержать любое количество элементов и элементы могут быть разных типов, к примеру, целые числа, строки, кортежи, и т. д. Однако, множество не поддерживает изменяемые элементы, такие как списки, словари, и так далее

Рассмотрим пример создания множества в Python:

num_set = {1, 2, 3, 4, 5, 6}  
print(num_set)
Результат:
{1, 2, 3, 4, 5, 6}

Только что мы создали множество чисел. Мы также можем создать множество из строк. Например:

string_set = {"Niholas", "Michelle", "John", "Mercy"}  
print(string_set)
Результат:
{'Michelle', 'Nicholas', 'John', 'Mercy'}


Возможно вы обратили внимание на то, что элементы в выдаче выше находятся в другом порядке, отличном от того, как мы добавляли их в множество. Это связано с тем, что элементы множества находятся в произвольном порядке. Если вы запустите тот же код еще раз, возможно вы получите выдачу с элементами, которые каждый раз будут находиться в другом порядке.

Мы также можем создать множество с элементами разных типов. Например:

Python
mixed_set = {2.0, "Nicholas", (1, 2, 3)}  
print(mixed_set)
Результат:
{2.0, 'Nicholas', (1, 2, 3)}


Доступ к элементам множеств
Python не предоставляет прямой способ получения значения к отдельным элементам множества. Однако, мы можем использовать цикл для итерации через все элементы множества. Например:

Python
months = set(["Jan", "Feb", "March", "Apr", "May", "June", "July", "Aug", "Sep", "Oct", "Nov", "Dec"])
 
for m in months:  
    print(m)
    
Результат:

Python
March  
Feb  
Dec  
Jan  
May  
Nov  
Oct  
Apr  
June  
Aug  
Sep  
July

Мы также можем проверить наличие элемента во множестве при помощи in, как показано ниже:
months = set(["Jan", "Feb", "March", "Apr", "May", "June", "July", "Aug", "Sep", "Oct", "Nov", "Dec"])
 
print("May" in months)

Результат:

True

Добавление элементов во множество
Python позволяет нам вносить новые элементы во множество при помощи функции add(). Например:

Python
months = set(["Jan", "March", "Apr", "May", "June", "July", "Aug", "Sep", "Oct", "Nov", "Dec"])
 
months.add("Feb")
print(months)

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Итерация: цикл по структурам данных
Как мы узнали из основ Python, итерация списка (который List) очень проста. Разработчики Python, обычно используют цикл For. Давай сделаем это:

bookshelf = [
  "The Effective Engineer",
  "The 4 hours work week",
  "Zero to One",
  "Lean Startup",
  "Hooked"
]

for book in bookshelf:
    print(book)	

Объявим список с книгами - bookshelf. Теперь для каждой книги на полке мы (а, можем все с ней делать) выводим ее, при помощи команды print. Довольно просто и интуитивно понятно.


Для хэш-структуры данных (словаря) мы также можем использовать цикл for, но мы применяем ключ:

dictionary = { "some_key": "some_value" }

for key in dictionary:
    print("%s --> %s" %(key, dictionary[key]))
    
# some_key --> some_value

Это пример того, как его использовать. Для каждого ключа в словаре мы печатаем ключ и соответствующее ему значение.

Другой способ сделать это - использовать метод items, который вернет нам ключ и значение. Используем его для словаря, что будет выглядеть как dictionary.items()

dictionary = { "some_key": "some_value" }

for key, value in dictionary.items():
    print("%s --> %s" %(key, value))

# some_key --> some_value	
Мы назвали эти два параметра key и value, но это не обязательно. Мы можем называть их как угодно. Давай посмотрим:

dictionary_tk = {
  "name": "Leandro",
  "nickname": "Tk",
  "birthplace": "Brazil",
  "age": 24
}

for attribute, value in dictionary_tk.items():
    print("My %s is %s" %(attribute, value))
    
# My name is Leandro
# My nickname is Tk
# My birthplace is Brazil
# My age is 24	
Мы видим, что мы использовали атрибут в качестве параметра для ключа словаря, и он работает правильно. Отлично!

	
=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Функция - это блок кода, который запускается только при его вызове. Вы можете передавать данные, называемые параметрами, в функцию. В результате функция может возвращать данные. Все как везде

В Python функция определяется с помощью ключевого слова def:

def my_function():
  print("Hello from a function") 	
Чтобы вызвать функцию, используйте имя функции, за которым следует скобка:

def my_function():
  print("Hello from a function")

my_function()	


Информация может быть передана в функции как аргументы. Аргументы указываются после имени функции в круглых скобках. Вы можете добавить сколько угодно аргументов, просто разделив их запятыми. В следующем примере есть функция с одним аргументом fname. Когда функция вызывается, мы передаем имя, которое используется внутри функции для печати полного имени:

>>> def my_function(fname):
...   print(fname + " Refsnes")
... 
>>> my_function("Emil")
Emil Refsnes
>>> my_function("Tobias")
Tobias Refsnes
>>> my_function("Linus") 
Linus Refsnes


По умолчанию функция должна вызываться с правильным количеством аргументов. Это означает, что если ваша функция ожидает 2 аргумента, вы должны вызвать функцию с 2 аргументами, не больше и не меньше. Если вы попытаетесь вызвать функцию с 1 или 3 аргументами, то получите ошибку.

def my_function(fname, lname):
  print(fname + " " + lname)

my_function("Emil", "Refsnes") 	

Если вы не знаете, сколько аргументов будет передано вашей функции, добавьте * перед именем параметра в определении функции.

def my_function(*kids):
  print("The youngest child is " + kids[2])

my_function("Emil", "Tobias", "Linus") 


>>> def my_function(*kids):
...    print("The youngest child is " + kids[0])
... 
>>> my_function("Emil", "Tobias", "Linus")
The youngest child is Emil


Мы можем использовать значение параметра по умолчанию. Если мы вызываем функцию без аргументов, то она не сломается и будет использовать значение по умолчанию:

def my_function(country = "Norway"):
  print("I am from " + country)

my_function("Sweden") #I am from Sweden
my_function() #I am from Norway


Вы можете отправить любой тип данных аргумента функции (строка, число, список, словарь), И он будет обрабатываться как тот же тип данных внутри функции.

Например если вы отправите список в качестве аргумента, он все равно будет списком, когда достигнет функции:

def my_function(food):
  for x in food:
    print(x)

fruits = ["apple", "banana", "cherry"]

my_function(fruits)




Ну и чтобы позволить функции вернуть значение, используйте оператор return:

def my_function(x):
  return 5 * x

print(my_function(3)) #15
print(my_function(5)) #25


=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Пользовательский ввод Python

Python позволяет вводить данные пользователем. Это означает, что мы можем попросить пользователя ввести данные.

Этот метод немного отличается в Python 3.6 от Python 2.7. 

Python 3.6 использует метод input().
username = input("Enter username:")
print("Username is: " + username)


Python 2.7 использует метод raw_input().
username = raw_input("Enter username:")
print("Username is: " + username)

Python прекращает выполнение, когда доходит до функции input (), и продолжает выполнение, когда пользователь ввел некоторый ввод.

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Обработка ошибок Python

Блок try позволяет вам проверить блок кода на наличие ошибок.
Блок except позволяет вам обрабатывать ошибку.
Блок finally позволяет выполнять код независимо от результата блоков try и except.



Обработка исключений
Когда возникает ошибка или исключение, как мы это называем, Python обычно останавливается и генерирует сообщение об ошибке.

Эти исключения можно обрабатывать с помощью оператора try:

try:
  print(x)
except:
  print("An exception occurred") 	


Блок try сгенерирует исключение, потому что x не определен.
Поскольку блок try вызывает ошибку, блок except будет выполнен. Без блока try программа выйдет из строя и выдаст ошибку.

Вы можете определить столько блоков исключений, сколько захотите, например если вы хотите выполнить специальный блок кода для особого типа ошибки.

try:
  print(x)
except NameError:
  print("Variable x is not defined")
except:
  print("Something else went wrong") 	

Выведите одно сообщение, если блок try вызывает NameError, а другое - для других ошибок.

Вы можете использовать ключевое слово else, чтобы определить блок кода, который будет выполняться, если ошибок не возникло:

try:
  print("Hello")
except:
  print("Something went wrong")
else:
  print("Nothing went wrong") 	
  
Блок finally, если он указан, будет выполнен независимо от того, вызывает ли блок try ошибку или нет.

try:
  print(x)
except:
  print("Something went wrong")
finally:
  print("The 'try except' is finished") 	

Чтобы вызвать (или выкинуть) исключение, используйте ключевое слово raise.

x = -1

if x < 0:
  raise Exception("Sorry, no numbers below zero") 	
  
Вы можете определить, какую ошибку выдавать, и текст, который будет выводить пользователь.

x = "hello"

if not type(x) is int:
  raise TypeError("Only integers are allowed") 	
=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Классы и объекты

Объекты представляют собой объекты реального мира, таких как автомобили, собаки или велосипеды. У объектов есть две основные характеристики: данные и поведение.

У автомобилей есть данные, такие как количество колес, количество дверей и вместимость. Они также демонстрируют поведение: они могут ускоряться, останавливаться, показывать, сколько топлива осталось, и многое другое.

Мы идентифицируем данные как атрибуты, а поведение как методы в объектно-ориентированном программировании.


А класс - это чертеж или план, из которого создаются отдельные объекты. В реальном мире мы часто находим много объектов одного типа. Как машины. Каждая машина была построена по одному и тому же набору чертежей и состоит из одинаковых компонентов (у всех есть двигатель, колеса, двери и т.д.).

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Объектно-ориентированное программирование Python
Python как объектно-ориентированный язык программирования имеет следующие концепции: класс и объект.

Класс - это план или чертерж, модель для своих объектов.

Итак, опять же, класс - это просто модель или способ определения атрибутов и поведения. Например, класс транспортного средства имеет свои собственные атрибуты, определяющие, какие объекты являются транспортными средствами. Количество колес, тип бака, вместимость и максимальная скорость - все это атрибуты транспортного средства.

Имея это в виду, давайте посмотрим на синтаксис Python для классов:

class Vehicle:
    pass	

!-!-!-!-!-!-!!-!-!-!-!-!-!    
pass это оператор-заглушка, равноценный отсутствию операции. Тут мы используем его потому что еще не указали атрибуты.
!-!-!-!-!-!-!!-!-!-!-!-!-!

Мы определяем классы с помощью оператора class - и все. Легко, правда?

Объекты - это экземпляры класса. Мы создаем экземпляр, называя класс.

car = Vehicle()
print(car) # <__main__.Vehicle instance at 0x7fb1de6c2638>
Здесь car - это объект (или экземпляр) класса Vehicle.


Помните, что у нашего класса транспортных средств есть четыре атрибута: количество колес, тип бака, вместимость и максимальная скорость. Мы устанавливаем все эти атрибуты при создании объекта транспортного средства. Итак, здесь мы определяем наш класс для получения данных, когда он их инициирует:

class Vehicle:
    def __init__(self, number_of_wheels, type_of_tank, seating_capacity, maximum_velocity):
        self.number_of_wheels = number_of_wheels
        self.type_of_tank = type_of_tank
        self.seating_capacity = seating_capacity
        self.maximum_velocity = maximum_velocity	
Метод __init__, который автоматически вызывается при создании объектов называется конструктором объектов класса
Переменная self представляет текущий объект класса.





https://wiki.merionet.ru/articles/rukovodstvo-po-izucheniyu-python-s-nulya-s-primerami/






=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
!-!-!-!-!-!-!!-!-!-!-!-!-!
протокол jdbc в python для получения доступа к БД
!-!-!-!-!-!-!!-!-!-!-!-!-!


=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Для выполнения Linux команд в Python можно использовать модуль subprocess. Этот модуль предоставляет мощные возможности для запуска новых процессов, получения их вывода и взаимодействия с ними.

>>> import subprocess
>>> process = subprocess.run(['ls', '-l', '-a'])

Пример использования:

Python

import subprocess

# Выполнение команды 'ls'
result = subprocess.run(['ls', '-l'], capture_output=True, text=True)

# Вывод результата
print("Output:\n", result.stdout)
print("Error:\n", result.stderr)

В этом примере:
1. Мы импортируем модуль subprocess.
2. Используем метод subprocess.run() для выполнения команды ls -l.
3. Параметр capture_output=True означает, что мы хотим захватить вывод команды.
4. Параметр text=True конвертирует байты в строку.
5. Результат команды выводится с помощью result.stdout (стандартный вывод) и result.stderr (вывод ошибок, если есть).

Если нужно выполнить команду и одновременно передать входные данные или обработать вывод построчно, можно использовать subprocess.Popen:

Python

import subprocess

# Запуск команды 'grep' и передача на стандартный ввод строки
process = subprocess.Popen(['grep', 'test'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, text=True)
output, error = process.communicate(input='test\ntest string\nanother line')

print("Output:\n", output)
print("Error:\n", error)

В этом примере:
1. Команда grep запускается с помощью subprocess.Popen.
2. Передаём строки на стандартный ввод с помощью process.communicate().
3. Получаем стандартный вывод и ошибки.



> ChatGPT4 | Midjourney:
Для того чтобы передать команду из терминала в Python-скрипт, можно использовать модуль sys, который позволяет работать с аргументами командной строки. Эти аргументы доступны через sys.argv. Вот пример, как это можно сделать:

1. Создайте Python-скрипт, назовем его, например, run_command.py:

import sys
import subprocess

def main():
    # Проверяем, что аргументы переданы
    if len(sys.argv) < 2:
        print("Usage: python run_command.py '<command>'")
        sys.exit(1)

    # Получаем команду из аргументов командной строки
    command = sys.argv[1]

    # Выполняем команду
    result = subprocess.run(command, shell=True, capture_output=True, text=True)

    # Выводим результат выполнения команды
    print(result.stdout)

if __name__ == "__main__":
    main()


2. Откройте терминал и выполните скрипт с командой в качестве аргумента:

python run_command.py "ls -l"


Здесь:
- sys.argv[1] содержит первый аргумент командной строки, который передается скрипту. Это будет команда, которую вы хотите выполнить.
- Скрипт run_command.py захватывает этот аргумент, выполняет команду и выводит результат на экран.

Таким образом, вы можете передавать любую команду Linux в ваш Python-скрипт через терминал.

> Егор:
что значит эта запись 
if name == "main":
    main()

> ChatGPT4 | Midjourney:
Выражение if __name__ == "__main__": является стандартной конструкцией в Python для проверки того, запущен ли скрипт как основная программа или он был импортирован как модуль в другой скрипт. Давайте разберемся, что это означает и как это работает:

1. __name__: В Python каждый файл даже с кодом является модулем, и каждый модуль имеет специальное встроенное атрибутное имя __name__. Когда модуль запускается (исполняется) напрямую, интерпретатор устанавливает значение __name__ для этого модуля как "__main__".

2. "__main__": Это специальное имя, которое означает, что модуль запущен как программа (основной скрипт), а не импортирован как библиотека.

Таким образом, если мы хотим, чтобы определенный блок кода выполнялся только тогда, когда скрипт запускается напрямую, а не при его импорте, мы используем следующую конструкцию:

def main():
    print("Этот скрипт был запущен напрямую")

if __name__ == "__main__":
    main()


Теперь рассмотрим по шагам:

- Определение функции main(): В данном примере мы определяем функцию main(), которая выполняет некоторую задачу (например, печатает строку).

- Проверка if __name__ == "__main__":: Эта проверка используется для определения, запущен ли текущий файл напрямую.

  - Если __name__ равно "__main__", значит, скрипт запущен как основная программа. В этом случае выполняется вызов функции main().
  - Если скрипт импортирован как модуль в другой файл, имя модуля будет присвоено __name__, и проверка не пройдет. Таким образом, функция main() не выполнится.

Это позволяет писать код, который может быть как использован напрямую, так и импортирован в качестве модуля без выполнения нежелательных действий.

Пример:

1. Основной скрипт (запуск напрямую):
      python script.py
   
   Вывод:
      Этот скрипт был запущен напрямую
   

2. Импорт в другой файл:
      import script

   # Вызов функции явно (если необходимо)
   script.main()
   

   В этом случае код внутри if __name__ == "__main__": не выполнится автоматически при импорте.



























