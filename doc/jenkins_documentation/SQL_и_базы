Структура запроса в SQL
=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Когда мы говорим о базе данных, мы имеем в виду множество информации, которая хранится в электронном виде. Эта информация организована в таблицы. Таблица состоит из строк и столбцов. Строки - это отдельные записи, а столбцы - это разные атрибуты, которые описывают каждую запись.
Число записей в таблице - это количество всех строк в этой таблице. Это может быть количество клиентов, заказов, товаров и т.д.

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

в запросе SELECT, а затем — строку, которую необходимо отобразить. 
Чтобы программа поняла, что относится к строке, фразу нужно взять в одинарные кавычки. Точка с запятой означает конец запроса.

SELECT 'Здравствуйте, я ваш первый запрос!'; 


SELECT умеет не только отображать строки, но и выполнять арифметические операции, можно решать арифметические примеры
SELECT 3+2; 
SELECT (8+2)/5; 

!!Запрос для выгрузки данных

Чтобы указать, какую информацию выгрузить из таблицы, добавляют инструкцию после SELECT. Символ * в SQL означает «всё». Получается команда «выбрать всё». 
После слова FROM указывают таблицу, из которой нужно выгрузить данные. В нашем случае это будет таблица buyer. Получаем запрос «выбрать всё из таблицы buyer». 

SELECT *
FROM buyer; 


Теперь подсчитаем число записей в таблице. Сделаем это, поместив символ * в оператор COUNT (англ. «посчитать»):

SELECT COUNT(*)
FROM buyer; 

Оператор COUNT() подсчитывает число записей. А поскольку в операторе мы указали *, запрос можно перевести как «подсчитать всё».



=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Ограничение выгрузки полей с помощью SELECT
В SQL существует простой алгоритм выгрузки части полей. После SELECT указывают только те поля, которые необходимо отобразить. Названия полей перечисляют через запятую.

выгрузим только три поля — last_name, first_name, gender

SELECT last_name,
       first_name,
       gender
FROM buyer; 


Переименование поля с помощью AS
Каждому полю в запросе можно назначить псевдоним, или алиас. Для этого после нужного поля указывают оператор AS (англ. «как») и пишут псевдоним.

SELECT first_name,
       age AS age_client,
       connection_area AS area
FROM buyer; 

Псевдоним — это новое имя поля в итоговой таблице. Псевдоним используют в некоторых случаях:

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Как ограничить выгрузку строк
Несколько строк из таблицы выводят, чтобы ознакомиться с ней и оценить данные. Для этого используют операторы LIMIT и OFFSET.

Оператор LIMIT
Этот оператор ставят в конце запроса и после него указывают количество записей (строк), которые нужно выгрузить. 

Такой запрос отобразит десять записей из перечисленных полей: 
SELECT поле_1,
       поле_2,
       поле_3
             ...
FROM таблица
LIMIT 10; 


Оператор OFFSET
Если нужно указать, с какой записи начинать выборку, к оператору LIMIT добавляют оператор OFFSET. Он позволяет пропустить определённое число записей

SELECT поле_1,
       поле_2,
       поле_3
             ...
FROM таблица
LIMIT 10 OFFSET 5; 

Такой запрос выведет записи с 6 по 15. Запрос ниже выведет записи с 1 по 10:
SELECT поле_1,
       поле_2,
       поле_3
             ...
FROM таблица
LIMIT 10 OFFSET 0; 

OFFSET — самостоятельный оператор. Чтобы отобразить записи всей таблицы, начиная с определённой, указывают только оператор OFFSET без оператора
LIMIT. Например, если нужно отобразить всю таблицу, начиная с шестой записи, запрос будет выглядеть так:


=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Типы данных SQL 
Типы данных SQL — это маркеры, которые указывают на свойства данных и необходимый объём памяти для их хранения.

Kлассификация основных типов данных в PostgreSQL:



*Числовые данные
Чаще всего используют тип, которым отображают целые числа, — integer, или int. Он хранит неделимые значения, то есть такие, которые нельзя представить с дробной частью. Например, 10 заказов, 18 покупателей или 3 отдела.
Для дробных чисел используют типы numeric или float. Они позволяют хранить числа, у которых предусмотрена часть после запятой: стоимость 3,52 рубля, среднее время сессии 18,2 минуты и так далее.



*Строковые, или текстовые, данные
База данных может содержать ФИО клиентов, их адреса, описания товаров или примечания. Например, в базе заказов онлайн-магазина бывают комментарии для курьеров: «позвонить у подъезда, домофон не работает», которые тоже хранятся в формате текста. В таких случаях используют строковые типы данных SQL.
Для отображения текстовой информации подойдут типы varchar и text.

character varying(n) / varchar(n)	строка ограниченной переменной длины	Если длина строки будет меньше, чем заявлено в скобках, система сохранит строку в исходном виде и не будет заполнять недостающие символы пробелами.Если ограничение по длине строки не задано, принимает строки любого размера.

text	строка неограниченной переменной длины	Принимает строки любой длины, если ограничение не задано.


*Дата и время
Во всех СУБД есть специальные типы данных для работы с датой и временем. Теоретически даты можно указывать и прописью, например «5 сентября 2022 года». Но тогда аналитику будет сложно найти все сделки за последний месяц или год. Для этого понадобится сначала выяснить, есть ли в нужной колонке слово «сентябрь». А если месяц в базе указан по-разному — «сент», «сент.» или september, — данные придётся унифицировать, и работа займёт гораздо больше времени. 

Вместо этого сразу устанавливают тип данных date и получают унифицированный формат записи в базе.

date	дата	4 байта
time	время	8 байтов

*Булевые, или логические, данные
Иногда в таблице достаточно зафиксировать простое «да или нет», «true или false», «0 или 1». Например, чтобы в базе компаний отметить, какие из них ещё работают, а какие — закрыты. Такую информацию можно хранить и в текстовом формате, но куда проще использовать для решения этой задачи специальный тип данных: boolean, или bool.

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Как задать условия выборки. Оператор WHERE
Выгрузить конкретные поля и строки — ещё полдела. Часто данные нужно отфильтровать: выгрузить информацию за конкретный период или с конкретным условием. Например, получить строки, где количество купленного товара превышает 4 штуки. 

Для таких задач в SQL используют условный оператор WHERE. Его указывают после оператора FROM:
SELECT поле_1, -- поля для выгрузки
       поле_2 
             ...
FROM таблица -- таблица, из которой выгружают данные
WHERE поле > 4; -- условие для среза данных 


Задать условия можно с помощью операторов сравнения. Они выглядят так:
= — равно;
!= — не равно;
> — больше;
< — меньше;
>= — больше или равно;
<= — меньше или равно.
Сравнение с числом записывают просто: WHERE поле < 5. Но если значение сравнивают с символьным типом, набор символов нужно взять в одинарные кавычки: WHERE поле = 'Иванов'. Это правило также касается даты и времени: WHERE поле = '2013-07-01'.

Поле, по которому формируется условие, необязательно должно присутствовать в SELECT. 
Например, укажем в запросе после SELECT только поле с фамилиями клиентов и при помощи оператора WHERE добавим условие: их возраст больше 50 лет. Тогда в итоговой таблице мы получим фамилии клиентов старше 50. 
В PostgreSQL в операторе WHERE нельзя использовать псевдонимы. Потому что «под капотом» во время компиляции WHERE выполняется раньше, чем SELECT, когда псевдонимы ещё не назначены.






Cложные условия для выборки


Операторы AND и OR
Операторы AND и OR позволяют объединять условия. AND применяют в том случае, если выгружаемые данные должны соответствовать всем перечисленным условиям.

Объединим два условия и отберём всех клиентов с первым подключением в зоне «Роботический лабиринт» и старше 30 лет: 
WHERE connection_area = 'Роботический лабиринт'
  AND age > 30; 
  
Отобрать данные, которые удовлетворяют одному из условий, можно оператором OR:
WHERE age > 30 
  OR age < 20; 



Оператор NOT

Чтобы отобрать клиентов из всех зон, кроме зоны «Роботический лабиринт», можно «перевернуть» условие оператором NOT. С его помощью выгружают записи, которые не соответствуют условию:

WHERE NOT connection_area = 'Роботический лабиринт' 

Оператор NOT используют и в нескольких условиях. В результате такого запроса следом за тридцатилетними из выборки пропадут и двадцатилетние:

WHERE NOT age = 30
  AND NOT age = 20; 


Оператор IN
Оператор IN работает так же, как несколько операторов OR — элементами списка могут быть и числовые типы данных, и строковые, и даты.

Если условий, которые нужно перечислить в операторе OR, очень много, то код получится громоздким. Например, нужны все пользователи с именами Виктор, Любовь, Борис, Станислав, Алина, Евгения и Ольга старше 25 лет. Если использовать операторы OR и AND, то код выйдет таким:
WHERE age > 25 
  AND (first_name = 'Виктор', 
       OR first_name = 'Любовь',
       OR first_name = 'Борис',
       OR first_name = 'Станислав',
       OR first_name = 'Алина',
       OR first_name = 'Евгения',
       OR first_name = 'Ольга'); 
 
       
Этот код выдаст верный результат, но чтобы много раз не перечислять один и тот же оператор, можно просто использовать оператор IN:
WHERE age > 25 
  AND first_name IN ('Виктор', 'Любовь', 'Борис', 'Станислав', 'Алина', 'Евгения', 'Ольга');        


Оператор IN можно комбинировать с другими логическими операторами. Его работу с AND вы видели в предыдущем примере. А вот как бы выглядел код, если бы нужно было отобрать всех пользователей, имя которых не входит в список:
WHERE age > 25 
  AND first_name NOT IN ('Виктор', 'Любовь', 'Борис', 'Станислав', 'Алина', 'Евгения', 'Ольга'); 



Правила действия логических операторов


Поведение операторов описано правилами. Условия, которые вы объединяете в запросе после WHERE, представляют собой утверждения. В нашем запросе их два:
WHERE age = 30
   OR age = 20; 
В переводе с языка SQL на человеческий эти утверждения выглядят так:
Клиенту 30 лет.
Клиенту 20 лет.

Каждое утверждение проходит проверку на истинность. На выходе получаем либо значение TRUE, если утверждение истинно, либо FALSE — если ложно. 
Каждый из логических операторов действует по своим правилам:
AND возвращает TRUE, только если оба логических значения тоже TRUE.
OR возвращает TRUE, если хотя бы одно логическое значение тоже TRUE.
NOT меняет значение выражения на противоположное: TRUE на FALSE, а FALSE на TRUE.


SELECT *
FROM buyer
WHERE age < 30
  AND gender = 'Мужской'
  AND NOT connection_area = 'Футуристический цирк'
  OR bracelet_id = 145767; 
  
В таблицу не войдут записи о клиентах, возраст которых больше либо равен 30, кроме тех, в которых идентификатор покупателя равен 145767.

В таблицу попадут записи о клиентах, которые подключились во всех зонах, кроме «Футуристический цирк». Также в выборку попадут все записи с идентификатором браслета, равным 145767.



Приоритет операторов
!!!!!!!!! Чем больше условий, тем сложнее уследить за логикой операторов. Условия с разными логическими операторами имеют разный приоритет. Первым всегда выполняется условие с оператором NOT, за ним — AND и в последнюю очередь — условие с OR. !!!!!!


WHERE age > 30
  AND connection_area = 'Роботический лабиринт'
  OR connection_area = 'Интерактивный музей робототехники'
  AND age < 20; 
  
       ||
  
WHERE (age > 30
  AND connection_area = 'Роботический лабиринт')
  OR (connection_area = 'Интерактивный музей робототехники'
  AND age < 20);   
  
Первые посетители «Роботического лабиринта» старше 30 лет.
Первые посетители «Интерактивного музея робототехники» младше 20 лет.
  


Если добавить скобки, можно не сомневаться, что в выборку попадут нужные данные. 
Сравните с другим условием:
WHERE age > 30
  AND (connection_area = 'Роботический лабиринт'
  OR connection_area = 'Интерактивный музей робототехники');
 
Условие в скобках приоритетнее — значит, в таблицу попадут первые посетители двух зон, чей возраст больше 30 лет.
=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Как работать с датой и временем

Фильтрация по дате
Отфильтруем таблицу hotdog по датам — отберём заказы, сделанные с 27 февраля 2022 по 14 марта 2022 года. Данные в поле хранятся в формате YYYY-MM-DD.

SELECT *
FROM hotdog
WHERE date >= '2022-02-27' AND date <= '2022-03-14'; 


Функции DATE_TRUNC и EXTRACT используются для выделения отдельных элементов даты.
DATE_TRUNC: усечение даты и времени до необходимого значения.
EXTRACT: получение конкретной части даты (год, месяц, минута, секунда, миллисекунда).

Функция DATE_TRUNC

Дата и время часто хранятся в таком виде: '2009-11-19 11:03:05'. Но сравнивать даты в таком формате неудобно, если нужен, например, только год. 
В таких случаях в PostegreSQL используют функцию DATE_TRUNC, которая «усекает» дату и время до необходимого значения. Синтаксис функции такой: DATE_TRUNC('отрезок времени', поле). 

Отрезок времени может быть разным, главное — не забыть одинарные кавычки:

'microseconds' — микросекунды;
'milliseconds' — миллисекунды;
'second' — секунда;
'minute' — минута;
'hour' — час;
'day' — день;
'week' — неделя;
'month' — месяц;
'quarter' — квартал;
'year' — год;
'decade' — десятилетие;
'century' — век.


Применим функцию DATE_TRUNC для этого поля. Для наглядности отобразим исходное поле с датой и поле с выделенным элементом даты. Выведем только первые пять строк:

SELECT date,
       DATE_TRUNC('month', date)
FROM hotdog
LIMIT 5; 

date	        date_trunc
2022-02-17	2022-02-01
2022-02-22	2022-02-01
2022-03-04	2022-03-01
2022-03-29	2022-03-01
2022-01-07	2022-01-01

Отфильтруем заказы хот-догов в феврале.

SELECT order_id,
       bracelet_id,
       date,
       name_hotdog,
       ingredients
FROM hotdog
WHERE DATE_TRUNC('month', date) = '2022-02-01'
LIMIT 5; 

order_id	bracelet_id	date	name_hotdog	ingredients
1	145907	2022-02-17	Классический Взрыв Вкуса	6
2	145784	2022-02-22	Карибский Потоп	5
8	145864	2022-02-16	Пикантный Полумесяц	7
15	145885	2022-02-27	Азиатская Симфония	5
20	145863	2022-02-03	Здоровый Зефир	8


Пример: вы усекаете данные до месяца из даты 2023-03-04. После использования DATE_TRUNC вы получите следующий результат: 2023-03-01 00.00.00.




Функция EXTRACT

Чтобы получить только конкретную часть даты — год, месяц или минуту, — используют функцию EXTRACT. Её синтаксис: EXTRACT(отрезок времени FROM поле). 
Одинарные кавычки для значений внутри EXTRACT не нужны. Отрезок времени можно представить следующими значениями:
CENTURY — век;
YEAR — год;
QUARTER — квартал;
MONTH — месяц;
WEEK — неделя в году;
DAY — день;
DOY (от англ. day of the year) — день года, выраженный числом от 1 до 365 или 366, если год високосный;
DOW (от англ. day of the week) — день недели, выраженный числом от 0 до 6, где понедельник — 1, воскресенье — 0.
ISODOW (от англ. day of the week и ISO 8601) — день недели, выраженный числом от 1 до 7, где понедельник — 1, воскресенье — 7;
HOUR — час;
MINUTE — минута;
SECOND — секунда;
MILLISECOND — миллисекунда.
Выделим номер недели из поля с датой так же, как ранее мы делали с месяцем. На этот раз применим EXTRACT:
SELECT date,
       EXTRACT(WEEK FROM date)
FROM hotdog
LIMIT 5; 


date	extract
2022-02-17	7
2022-02-22	8
2022-03-04	9
2022-03-29	13
2022-01-07	1




Давайте отфильтруем данные: оставим только те заказы, которые проходили на седьмой неделе.
SELECT order_id,
       bracelet_id,
       date,
       name_hotdog,
       ingredients
FROM hotdog
WHERE EXTRACT(WEEK FROM date) = 7
LIMIT 5; 









=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Правило № 1. Выделение ключевых слов
Первое правило хорошего стиля — отделять ключевые слова от названий столбцов и таблиц. Ключевые слова пишут в верхнем регистре, а названия — в нижнем. 

SELECT *
FROM pizza; 



Правило № 2. Перенос строк
Второе правило хорошего стиля — перечислять поля и функции, перенося их на новую строку и выстраивая в один столбик. Так проще понять, какие поля или значения будут выгружены.

SELECT last_name,
       first_name,
       title
FROM staff; 


