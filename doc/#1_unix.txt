cmod -меняет атрибуты (чтение,запись и т.д. )

 =-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
11
 
 разграничение доступа к файлам 

Режимы доступа 

владелец	группа-владелец		остальные
 r w x		    r w x		  r w x
 4 2 1		    4 2 1 		  4 2 1
f
r-чтение
w-запись 
x-выполнение(заходить  внуть)

управение режимами доступа с командной строки
chown- смена владельца файла 
chgrp- смена владельца группы (g+r g+w g+x)
chmod- изменения разрешения файла ( можно менять r w x)
newgrp - изменяет первичную группу, будет указал при создании файла 

 
команда chown позволяет менять одновременно и владельца и группу chown [опции] владелец:группа файл. 
	chown -R root:root (имя деректории )- меняет доступ к фалу пользователя 

команда chmod позволяет менять права для группы владельцев и остальных пользователей
 	chmod 774 имя файла/деректория 
(тип файла) (права пользователя) (права группы) (права отстю пользоватлей)
    -			rwx		rw-			r--

для файла:

    r (read) - чтение файла разрешено, то есть можно просматривать его содержимое, открывать в текстовом редакторе.
    w (write) - запись файла разрешена, то есть можно его редактировать, переименовывать, удалять.
    x (execute) - исполнение файла разрешено. Это касается исполняемых файлов.

Для каталога:

    r (read) - разрешено просматривать содержимое  каталога, то есть можно воспользоваться командой ls и посмотреть какие файлы и каталоги содержаться в данном каталоге.
    w (write) - используется совместно с атрибутом x (execute). Позволяет удалять и переименовывать файлы в каталоге.
    x (execute) - при использовании совместно атрибутом r (read) позволяет увидеть атрибуты файла, то есть его размер, дату модификации, права доступа. Одним словом позволяет полноценно воспользоваться командой ls -l. При использовании совместно с атрибутом w (write) позволяет перейти в каталог командой cd, удалять и переименовывать файлы.

   Символьное представление прав доступа |  Числовое представление

		r (read)                 |		4
 
 		w (write)		  |  		2

		x (execute)		  |  		1

Символьное представление       |     Операция  |  Цифровое представление

	rwx			|     4 + 2 +1   |          7

	rw-                    |     4 + 2 + 0  |          6
	
	r--                    |     4 + 0 + 0  |          4

	r-x                    |     4 + 0 + 1  |          5

	-wx                    |     0 + 2 + 1  |          3
	
	-w-                    |     0 + 2 + 0  |          2

	--x                    |     0 + 0 + 1  |          1

	---                    |     0 + 0 + 0  |          0
	
	

	
Так как у нас права доступа разделяются на 3 категории (владелец, группа, остальные), то применяется трехзначное обозначение. Например, чтобы абсолютно всем назначить права rwx, то применяется команда chmod 777 notes.txt. 

Чтобы остальным пользователям разрешить только чтение файла, то есть r--, выполним chmod 774 notes.txt.  

Если хотим группе владельцев назначить права r-x, а остальным пользователям вообще все запретить, то выполним chmod 750 notes.txt.


Применение расширенных прав

Чтобы применить SUID, SGID и sticky bit, вы также можете использовать chmod. SUID имеет числовое значение 4, SGID имеет числовое значение 2, а sticky bit имеет числовое значение 1.

Если вы хотите применить эти разрешения, вам нужно добавить четырехзначный аргумент в chmod, первая цифра которого относится к специальным разрешениям. Следующая строка, например, добавит разрешение SGID на каталог и установит rwx для пользователя и rx для группы и других:

chmod 2755 /somedir

Для SUID используйте chmod u+s.
Для SGID используйте chmod g+s.
Для sticky bit используйте chmod +t, а затем имя файла или каталога, для которого вы хотите установить разрешения.

Изменение и просмотр настроек ACL с помощью setfacl и getfacl

Теперь давайте добавим ACL, чтобы дать права на чтение и выполнение и группе sales. Команда для этого setfacl -m g:sales:rx /dir.
В этой команде -m указывает, что текущие настройки ACL необходимо изменить. После этого g:sales:rx сообщает команде установить ACL для чтения и выполнения (rx) для группы (g) sales. Ниже вы можете увидеть, как выглядит команда, а также вывод команды getfacl после изменения текущих настроек ACL.

[root@server1 /]# setfacl -m g:sales:rx /dir
[root@server1 /]# getfacl /dir
getfacl: Removing leading '/' from absolute path names
# file: dir
# owner: root
# group: root
user::rwx
group::r-x
group:sales:r-x
mask::r-x
other::r-x

Например, команда setfacl -m u:linda:rwx /data дает разрешения пользователю linda в каталоге /data, не делая его владельцем и не изменяя назначение текущего владельца.
Один вариант особенно важен, параметр -R. Если используется, опция делает настройку ACL для всех файлов и подкаталогов, которые в настоящее время существуют в каталоге, где вы устанавливаете ACL. Рекомендуется всегда использовать эту опцию при изменении списков ACL для существующих каталогов.

Если вы хотите использовать ACL для настройки доступа нескольких пользователей или групп к одному и тому же каталогу, вы должны установить ACL дважды. Сначала используйте setfacl -R -m, чтобы изменить ACL для текущих файлов. Затем используйте setfacl -m d:, чтобы позаботиться обо всех новых элементах, которые также будут созданы.
Чтобы установить ACL по умолчанию, вам просто нужно добавить опцию d после опции -m (порядок имеет значение!). Поэтому используйте setfacl -m d:g:sales:rx /data, если вы хотите, чтобы группа sales имела доступ на чтение и выполнение всего, что когда-либо будет создано в каталоге /data.


удалять правило на группу 
sudo setfacl -x g:aptly db

# file: db
# owner: kshkarin
# group: share
user::rwx
group::r-x
group:aptly:rwx			#effective:r-x  -удалит
mask::r-x
other::r-x
default:user::rwx
default:group::r-x
default:group:aptly:rwx
default:mask::rwx
default:other::r-x

добавляет права
sudo setfacl -m  group:aptly:rwx db


# file: db
# owner: kshkarin
# group: share
user::rwx
group::r-x
group:aptly:rwx			-добавит
mask::r-x
other::r-x
default:user::rwx
default:group::r-x
default:group:aptly:rwx
default:mask::rwx
default:other::r-x



устанавливает права на все подпапки
sudo setfacl -R -m g:aptly:rwx db



=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Команда which
$ which bash
отображает путь до выполняемй команды 



=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


echo-отображение переменной echo $HISTFILE(отобразит каталог с расположением файла bash_history)
echo date (выведет слово date) 
echo `date` (выведет сегоднешнюю дату )

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

LANG-параметры языка LANG=en_En ls dir2(выведет сообщение на ангийком ) 

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

alias-создает переменные alias 1='ls -l' (при вводе 1 выведет значение команды = ls-l )

alias 192.168.55.245='ssh -t e.sermyagin@192.168.55.245 "/bin/bash"'


=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

mkdir-создание каталога mkdir test (создаст каталог test)
	mkdir $(date “+%d.%m”) создаст деректорию с текущей датой 
	
опция -p, которая говорит mkdir создавать любые отсутствующие родительские директории
	
mkdir -p easy/as/pie
	
=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
объеденение нескольких команд 
ls -l `which find` (отобразит кому принедлежит данный каталог)
       ||
ls -l $(which find) (отобразит кому принедлежит данный каталог)

rpm -qf `which find` (отобразит к какому пакету обнавлений относится команда find)

tr '[a-z]' '[A-Z]' (меняет нижний регистр в верхний )

ls -l /var/log > log.files (запишет значение вывода команды в файл )
cat log.files (отобразит значение файла log.files)
echo 'last line' >> log.files(дозапишит значение в конец файла)

перенапрвление потока ошибок
ls /fake 2> fake.log(перенаправило значение ошибки в файл fake.log)

>(перенаправление потока вывода)
2>(пернаправление потока ошибок)
&>(перенаправение потока вывода и потока ошибок)

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
find поиск
find [options][starting-point..][expression]
find /tmp -name 'ssh-*'(найдет все катологи начинающиеся с ssh)

locate поиск (быстрее чем find)
locate [options]..[pattern]
locate ssh(найдет все значения котрые имееют с воем назвмие ssh)

grep(внутри файла)
grep bash /etc/passwd (найдет все строки которые содержат bash )
grep -n bash /etc/passwd (найдет все строки которые содержат bash, и укажет номер этой строки 

	sudo cat /var/log/syslog | grep error (отличное сочетание для поиска в логах по ключевым словам)
	
	
чистит syslog	truncate -s 0 /var/log/syslog




перенаправит значение грепа в файл 
grep	 --line-buffered 'crc' >> ./serm/1 
	
grep -E  --line-buffered 'crc|SYSTEM: -- system stats --' >> ./serm/1

	
=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=	

which find (отобразит расположение команды ,файла...)


=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Информация о системе 
arch(архитектура системы)
uname -a(ифнормация об операцитонной системы)-версия ядра 
lsb_release -a -версия операционки
=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
cat >newfile.txt (создаст файл и далее можно ввести данные в терминалае при нажатии сочетания клавиш ctr+d ввод прекратися и данные сохранятся в файле)
=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

tale -f /etc/passwd (отобразит в реальном времяни какие изменения внесли в конц файла )

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

less (необходим для простмотра справки)

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

boot- файлы загрузки
bin- содержание утилит/команд  
sbin- инструменты системного администрарота и службы 
dev- фалы устройств (cdrom sda(диск))
etc- реестр ситемы (настроичные файлы системы )
home-домашний коталог пользователя
root-ломашний коталог root
lib-файлы библеотек, модули ядра,модули системы аутентификации, система инициализации, работа с подключаемыми устройствами
media-каталог для подключения внешних устройств 
mnt-времянное мантирование разделов 
opt-установка приложений типа programfiles
proc-внутреняя структура ядра
sys-информация о подключеном оборудовании (сетевые интерфейсы)
В нем вы найдете следующие подкаталоги: 

• blосk - содержит каталоги для всех блочных устройств, которые есть в вашей системе в настоящее время. Здесь под устройством подразумевается наличие физического устройства и его драйвера. Если вы подключите внешний жесткий диск, то в каталоге /sys/devices появится новое устройство, но в каталоге /sys/block оно появится только, если в системе есть драйвер для работы с этим устройством или же драйвер встроен в само ядро 

• bus - здесь находится список шин, которые поддерживает ваше ядро. Заглянув в этот каталог, обнаружите подкаталоги pci, pci_express, scsi и т.д. В каждом из этих каталогов будут подкаталоги devices и drivers. В первом находится информация об устройствах, подключенных к данной шине, во втором - информация о драйверах устройств 

• class - позволяет понять, как устройства формируются в классы. Для каждого класса есть отдельный подкаталог в каталоге class 

• devices - содержит дерево устройств ядра, точнее структуру файлов и каталогов, которая полностью соответствует внутреннему дереву устройств ядра 

• firmware - содержит интерфейсы, предназначенные для просмотра и манипулирования firmwаrе-специфичными объектами и их параметрами 

• fs - информация о файловых системах, которые поддерживает ваше ядро 

• kernel - общая информация о ядре 

• module - здесь найдете подкаталоги для каждого загруженного модуля ядра. Имя подкаталога соответствует имени модуля. В каждом из подкаталогов модулей найдете подкаталог parameters, содержащий специфичные для модуля параметры 

• power - позволяет управлять параметрами питания, а также переводить систему из одного состояния питания в другое.

srv-каталог файловых ресурсов (файлы не привязанные к конкретным пользователям )
var-изменяемые данные системы (log, mail,cache)
tmp-временные фалы 

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

/usr/share 

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

df -h -отображает состояние диска (занятое место) 
	
du -h /путь_к_файлу/имя файла -отображает размер файла 

lsblk- отображение дисков 




сfdisk -разбиение диска
gparted-разбиение дискf (с графическим интерфейсом)

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

файловые системы 
ext4 основная файловая система в alt

df-показывает перечень используемых сейчас файловых систем
mkfs-создание фаловой системы (форматирование в виндоус)

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

touch имя_файла - создает пустой файл

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

mount- монтирование фс mount /dev/sdb1 /mnt (примонтируется директорию sdb1 в раздел mnt)
mount -a примонтирует данные из файла /etc/fstab

umount- ремонтирвоание


mount ntfs
sudo mount -t ntfs -o nls=utf8,umask=0222 /dev/sdb1 /media/windows


c
=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Навигация по дереву каталогов 
pwd-текущее место работы 

cd-смена каталога 

ls- отображает параметры каталога
   -l (отображает права доступа на файлы и каталоги)
   -R (отображает содержимое подкатологов текущего каталога)
   -t (сортирует файлы по дате изменения)
   
 =-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=  
   
утилит touch (меняет дату изменениns][src(откуда)][dst(куда)](если указать имя то файл будет переименован)
	cp-копирвание 
	cp /test1/. /test2/ -r (скопирует все файлы из деректории test1 в том числе и скрыте)
	
	
корпирует файлы  в которых нашлось слово test	в папку search_test
	egrep -rl "test" ./ | xargs cp -t ~/serm/search_test/

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
	
 scp - сетвое копирование фалов 
  scp опции пользователь1@хост1:файл пользователь2@хост2:файл
    scp -P 9015 /home/esermyagin/file/NANOSWITCH3-MIB g10@192.168.55.99:/home/g10/serm
  
  
  выкачиваем с сервера ( ssh -p31977 g10@192.168.55.242   - проброс )
   scp -P 22 g10@192.168.55.242:/home/g10/g10.conf /home/esermyagin/
=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

	
 
 
утилита mv (пермещает файл) mv[potions][src(откуда)][dst(куда)](если указать то же расположение но поменяется имя файл будет переименован)
утилита rm(удаление)
rm -rf (удаление деректории и всего что в нех находится)
утилита rmdir (удаляет каталог только пустой)п
утилита du (отображет размер каталога) du /var 



удаление с помошью цикла 
i=fbarray_memseg-2048k-0-0_2; for ((n=0;n <100;n++)); do sudo rm $i$n*;done



=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


настройка сетевого интерфейса 
cat /etc/net/ifaces/имя интерфейса/options

ip l - отбражение интерфейсов



ip -s l -статистика
ip a - добавление сетефой адресации
ip r - отображение таблицы маршрутизации

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


атрибуты для пароля 
/etc/passwdqc.conf
min=n0,n1,n2,n3,n4 (пример min=disabled,24,11,6,7)

n0-для паролей состоящих из символов только одного класса
n1-для паролей состоящих из символов двух классов
n2-для парольных фраз, кроме этого требования длины парольная фраза должна так же состоять из достаточного количества ключевых слов
n3-для паролей состоящих из символов 3 классов 
n4-для паролей состоящих из символов 4 классов 

similar -разрешает/запрещает(permit/deny) задавать пароль если он похож на старый


управлени службами
systemctl-работа с сервисами 

https://itsecforu.ru/2019/08/30/🗂%EF%B8%8F-как-вывести-список-всех-запущенны/

systemctl --type=service список всех загруженных служб в вашей системе (независимо от того, активны ли они; запущены, завершились или вышли из строя)
systemctl --type=service --state=active -выведет список активных служб
systemctl --type=service --state=running - чтобы просмотреть все запущенные службы (т. е. все загруженные и активно запущенные службы)

расположение катлога сервисов /lib/systemd/system
systemctl enable-установка в авто загрузку
systemctl disble-отключение с автозагрузку
systemctl daemon-reload перечитка конфигурации 
systemctl start-запуск службы
systemctl stop-остановка службы 
systemctl restart-перезагрузка службы 
systemctl reload-перезагрузка службы c перечиткой конфигурации 


=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

утилита rpm 
использует базу /var/lib/rpm
установка пакетов в ситему rpm -i <файл пакета>
удаление пакета из системы rpm -e <имя пакета>
обнавление пакета rpm -U <файл пакета>

rpm запросы

опция-q установлен ли пакет в системе,дополнительно	
 -f какому пакету принадлежит файл
 -l вывод списка файло в данном пакете
 -a вывод всех устаноленных в системе пакетов
 -i подроная информация о пакете 
 -p запрос по файлу пакета. а не по базе rpm
опция-V проверка соответсвует ли установленное в системе пакету в базе rpm 

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Добавление пользователя 
	sudo adduser (имя пользователя) добавление пользователя
	passwd изменение пароля пользователя 
    
 Блокирование пользователя
 	блокировка пользователя  -L (--lock), для разблокировки -  -U (--unlock): 
	usermod -L имя_пользователя
    Проверка блокировки пользователя(P-разблокирован,L-заблокирован)
    	passwd -S имя_пользователя
    	
  Удалени пользователя 
	sudo deluser (имя пользователя)
	удаление пользователя, его домашней директории, и почты
	sudo deluser --remove-home (имя пользователя)
	
  Просмотр всех существующих пользователей 
	sed 's/:.*//' /etc/passwd
	


Права и группы пользователя 
     Добавление пользователя в группу
		
	Лучше использовать ы
		sudo gpasswd -a 
     	sudo gpasswd -a e.sermyagin ntdevel-rw
     	
     		usermod -G имя_группы  имя_пользователя 
		
 	sudo usermod -aG sudo (имя пользователя) проверка прав пользователя на sudo
  	sudo -l -U (имя пользователя) проверка прав пользователя через просмотр групп 
  	groups (имя пользователя) перечесление всех пользователей состоящих в группе sudo 
  		getent group (имя группы)
  		
     Изменение параметров групп: 
	для изменения параметров группы используются команда groupmod [опции] имя_группы.  
	для удаления группы - groupdel [опции] имя_группы 
	для изменения пароля и других параметров - gpasswd [опции] имя_группы

 

Файлы куда помещается информация при созданиии пользователей
/etc/passwd-учетные записи пользователей
/etc/shadow -информация о пароле пользователя
/etc/group-группы пользователей 
/etc/gshadow -информация о пароле группы
/etc/skel/ -инфомация о необходимых файлах, которые необходимы каждому пользователю, имеющему свой домашний каталог.



sudo -ll - подробный список разрешенных команд для sudo у текущего пользователя
	
	
	=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=	
	
	
	Пользователи и группы
	https://interface31.ru/tech_it/2020/01/linux-nachinayushhim-chast-6-upravlenie-polzovatelyami-i-gruppami-praktika.html

Создать пользователя в Linux можно командой useradd. К примеру, чтобы пользователя vasya добавить в систему, введите: 
sudo useradd -m vasya

Опция -m позволяет создать для пользователя домашний каталог, что в большинстве случаев приветствуется. 

Скорее всего, вы также захотите определить для пользователя предварительный пароль. Это можно сделать с помощью команды passwd, за которой следует имя пользователя: 
sudo passwd vasya

После выполнения этой команды вам будет предложено ввести новый пароль. 

Группы создаются с помощью команды groupadd таким же образом: 
sudo groupadd accounting 

Чтобы убедиться в том, что новая группа успешно создана, просмотрите файл /etc/ group: 
sudo grep accounting /etc/group 

Добавить пользователя vasya в новую учетную группу можно таким образом: 
sudo usermod -g accounting vasya

Чтобы просмотреть группы, к которым принадлежит vasya, используйте команду groups: 
groups vasya	


            =-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=	

Ubuntu по умолчанию поставляется с отключенной учетной записью root, и весь административный доступ осуществляется через программу sudo или ее эквивалент с графическим пользовательским интерфейсом. 

Если хотите, можете установить пароль root на Ubuntu, а затем разблокировать учетную запись с помощью команды: 
sudo passwd -u root
=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=	
		
Основные опции команды ssh:

    f - перевести ssh в фоновый режим;
    g - разрешить удаленным машинам обращаться к локальным портам;
    l - имя пользователя в системе;
    n - перенаправить стандартный вывод в /dev/null;
    p - порт ssh на удаленной машине;
    q - не показывать сообщения об ошибках;
    v - режим отладки;
    x - отключить перенаправление X11;
    X - включить перенаправление Х11;
    C - включить сжатие.
    
=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Заархивировать папку 
https://ru.wikihow.com/заархивировать-папку-в-Linux

15 примеров tar	
https://wiki.merionet.ru/servernye-resheniya/96/15-primerov-komandy-tar-dlya-sisadminov-i-devopsov/
	
распаковка файла с помощью команды:

	 tar -vxf (имя файла.xz)

Создайте архива
tar -cvf Имя.tar /путь/к/каталогу

tar cvzf file.tar.gz /path/to/directory

tar -cvf 123.tar 123


tar -czvf bina-i.tar.gz ./bina-i


=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=	

Чтобы установить deb пакет выполните команду:

sudo dpkg -i (имя файла).deb

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=	

sudo kill убивает процесс (если процесс подвис-KILL)

kill -s SIGSTOP 16224

убивает, останавливает или продолжает  !убивает повисший процесс!

SIGINT, SIGSTOP, или SIGCONT  !SIGKILL!


показывает процессы запущеныне в фоне 

jobs -l


[1]- 16217 Running                 xeyes -center red &amp
[2]+ 16224 Running                 xeyes -center blue &amp

Если нам нужно сразу запустить в фоновом режиме , мы можем просто добавить "&amp" (амперсанд) в конец команды
sudo openvpn --config /home/esermyagin/e.sermyagin01.ovpn &amp
=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=	


Очистка системы Ubuntu 20.04 должна начаться с выяснения, какие файлы потребляют больше всего пространства на диске.В этом вам поможет программа ncdu. Это консольная утилита с псевдографическим интерфейсом, но мне она нравится больше всего. Сначала её надо установить. Для этого выполните в терминале:

sudo apt install ncdu

Затем запустите программу:

ncdu /
	
=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=		
	
find . -type f -newermt 2019-10-31 ! -newermt 2019-11-02

* найдет все файлы, которые менялись в промежутке между 31.10.2019 и 01.11.2019 (включительно).

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=	

 lsb_release -a версия убунту 
 
		=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 	
 uname -a показывает версию ядра
 uname -m  Эта команда выведет архитектуру процессора. Если архитектура i686 или i386, это указывает на 32-битную систему. Если архитектура x86_64, это указывает на 64-битную систему.
 
  проверить является Linux 32-битным или 64-битным?
 getconf LONG_BIT

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Чтобы проверить, доступен ли SSH на удаленном сервере, выполните команду:

ssh localhost
	
	=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
в каком статусе нхаодятся ядра 
cat /sys/devices/system/clocksource/clocksource0/current_clocksource	
	
текущий clocksource
	=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
mount, локальной папки
Локальная папка на удаленной машине
Используя sshfs, можно примонтировать локальный каталог на удаленную машину:

localhost:~$ sshfs user@proglibserver:/media/data ~/data/g

	=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
	
stat filename - полная статистика по файлу 


rcync удаленное копирование файлов,
https://www.youtube.com/watch?v=LRq8LT_u7nY&t=92s
=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


Самая частая задача - это загрузка файлов linux. Скачать файл очень просто. Для этого достаточно передать утилите в параметрах имя файла или html страницы:


 curl https://raw.githubusercontent.com/curl/curl/master/README.md
 
 
=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

установка даты 

sudo date --set "Feb 24 14:17:20 2022"

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


команда чтобы посмотреть список разделов:


sudo fdisk -l

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

 зависимости команды cp
 
 ldd /bin/cp


 ldd /opt/nt/bin/ntfeeder
 
ldd – это утилита командной строки Linux, которая используется в том случае, если пользователь хочет знать зависимости от общей библиотеки исполняемого файла или даже библиотеки разделяемой библиотеки

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Ctrl+a переместить курсор в начало строки
Ctrl+e переместить курсор в конец строки
Ctrl+b переместить назад один символ
Alt+b Отодвинься на одно слово
Ctrl+f шаг вперед характер
Alt+f переместить вперед на одно слово
Ctrl+d удалить текущий символ
Ctrl+w вырезать последнее слово
Ctrl+k вырезать все после курсора
Alt+d вырезать слово после курсора
Alt+w вырезать слово перед курсор
Ctrl+y вставить последнюю удаленную команду
Ctrl+_ отменить
Ctrl+u вырезать все перед курсором
Ctrl+xx переключение между первой и текущей позицией
Ctrl+l очистить терминал
Ctrl+c отменить команду
Ctrl+r команда поиска в истории-введите поисковый запрос
Ctrl+j завершить поиск в текущей записи истории
Ctrl+g отменить поиск и восстановить исходную строку
Ctrl+n следующая команда из История
Ctrl+p предыдущая команда из истории

Перемещение по строке терминала
Alt-B. Отправляет курсор на одно слово назад.
Alt-F. Посылает курсор вперед на одно слово.


=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Настройка сетевого интерфейса при помощи ifconfig
Команда ifconfig позволяет конфигурировать сетевой интерфейс по вашему усмотрению и предлагает широкие возможности для этого.

Чтобы получить подробную информацию по команде, пишем в терминале:
man ifconfig

Если компьютер со статическим ip-адресом и не имеет доступа ни к другим сетям ни к интернету, то команда настройки сетевого интерфейса будет такой:

sudo ifconfig eth0 192.168.1.2 netmask 255.255.255.0 up

Поясняю:

eth0 — идентификатор сетевого оборудования (сетевая карта).

192.168.1.2 — присваеваемый ip-адрес.

netmask 255.255.255.0 — присваеваемая маска подсети.

up — поднять интерфейс (то есть применить изменения, начать работу сетевой карте).

down — остановить интерфейс.

Команда: sudo ifconfig eth0 down Т.е. остановить работу сетевой карты с eth0 идентификатором.

Бывает так, что провайдер интернет привязывает mac-адрес сетевой карты к учётке клиента. При замене сетевой карты или же компьютера, мы получим отсутствие интернета на нашей стороне. Как временное решение может подойти подмена реального mac-адреса, mac-адресом который был зарегистрирован у провайдера. Почему временное? Потому, что описанная ниже команда делает изменения которые удалятся, при перезагрузке компьютера.

Сначала выясняем наш старый mac-адрес, выполняем команду ifconfig без параметров.

Допустим он у нас такой: 00:00:00:00:00:01.

Производим следующие действия, то есть выполняем последовательность команд:

1) Отключаем интерфейс: ifconfig eth0 down

2) Изменяем MAC: ifconfig eth0 hw ether 00:00:00:00:00:01

3) Включаем интерфейс: ifconfig eth0 up

Все действия можно выполнить одной командой:

sudo ifconfig eth0 down && ifconfig eth0 hw ether 00:00:00:00:00:01 up

&& — означает, выполнить следующую команду при успешном выполнении предыдущей команды.

Как я писал выше, все эти настройки действительны лишь до перезагрузки системы. Сделаем их постоянными следующим образом:

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

tail - она позволяет выводить заданное количество строк с конца файла, а также выводить новые строки в интерактивном режиме.


tail -n20 g10.conf 
выведет последние 20 строк из g10.log


		-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

head выводит первые десять строк файла или потока. Используйте опцию -n, чтобы указать, сколько строк должно отображаться.
=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


netplan generate --mapping net0

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
watch grep \"cpu MHz\" /proc/cpuinfo

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

изменение приглашения bash
sudo mcedit ~/.bashrc

http://192.168.55.245/redmine/projects/support/wiki/Metrics

sudo hostnamectl set-hostname ns3-01.573.gprs.astrakhan.mts

было 

if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi

unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"

стало

if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@$(hostname)\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@$(hostname):\w\$ '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@$(hostname): \w\a\]$PS1"


обратить внимание на u@$(hostname)

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
немедленное выключение 

shutdown

 sudo shutdown -h now

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
принудительная перезагрузка


echo 1 > /proc/sys/kernel/sysrq
echo b > /proc/sysrq-trigger


=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

абсолютные пути

абсалютный путь начинается с /


относительные пути 

Другой тип пути называется «относительный путь». bash, cd, и другие команды всегда интерпретируют их относительно текущей директории. Относительные пути НИКОГДА не начинаются с /. 



Кроме того, мы также можем использовать ".." в существующем относительном пути, позволяющем нам переместиться в директорию «рядом» с той, в которой находимся:

	--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

$ pwd
/usr/local
$ cd ../share
$ pwd
/usr/share



=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

 Принудительная перезагрузка Linux, когда команда reboot не работает

echo s > /proc/sysrq-trigger # emergency sync of the block devices
echo u > /proc/sysrq-trigger # mount readonly of all filesystems
echo s > /proc/sysrq-trigger # sync
echo b > /proc/sysrq-trigger # force an immediate boot; you can also use o for poweroff.

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

информация о опертаивной памяти  
 cat /proc/meminfo
 
 free -m  
 
 sudo dmidecode --type memory

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=



Чтобы узнать какой типо иксов у вас установлен выполните

ls /usr/bin/*session
/usr/bin/byobu-select-session  /usr/bin/dbus-run-session  /usr/bin/gnome-session  /usr/bin/gnome-session-custom-session

Узнать версию GNOMEдобавать

gnome-shell --version
GNOME Shell 3.36.9

Как узнать, какую среду рабочего стола вы используете на Linux?

echo $XDG_CURRENT_DESKTOP
ubuntu:GNOME

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

чтобы посмотреть, есть ли у Вас библиотеки от пакета mysql, можно так:



sudo ldconfig -p|grep libntmetrics.so


=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Команда diff , для сравнения двух файлов, упоминалась ранее,  но что если нужно сравнить сразу три файла?

Команда diff3

Формат вызова:
diffЗ [параметры] файл1 файл2 файлЗ 

Выводит следующую информацию:
==== - все три файла разные; 
===1 - первый файл отличается от второго и третьего; 
===2 - второй файл отличается от первого и третьего; 
===З - третий файл отличается от первого и второго. 

Параметры:
-a - сравнивать файлы как текстовые, даже если они бинарные
-А - Создание сценария для редактора ed, который показывает в квадратных скобках все отличия между файлами.
-e - Создает сценарий для ed, который помещает все отличия между файлами файл2 и файлЗ в файл файл1 (будьте осторожны!)



=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
добавит часы в правый верхний угол терминала

while sleep 1;do tput sc;tput cup 0 $(($(tput cols)-29));date ;tput rc;done & 

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

К посту о [ поиске 5 самых больших файлов в системе ] можно добавить утилиту ncdu

После установки: sudo apt install ncdu

Запустив командой ncdu /
Программа с псведографическим интерфейсом позволит перемещаться по каталогам отмечая файлы, которые занимают больше всего пространства в той или иной директории.

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

когда mc нужно запускать от sudo 

Чтобы решить эту проблему укажем правильного владельца и группу на эти директории:

Cannot create

sudo chown -Rf g10:g10 /home/g10/.cache/;\
sudo chown -Rf g10:g10 /home/g10/.local/;\
sudo chown -Rf g10:g10 /home/g10/.config/;\




=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Для просмотра сообщений ядра используем команду
journalctl -k 

Команда покажет все сообщения ядра для текущей загрузки. 

Такую команду можно комбинировать с опцией -b, чтобы просмотреть сообщения ядра во время предыдущей загрузки:
journalctl -k -b -2

Но бывает такое, что в некоторых системах boot logging отключен и вместо лога предыдущих загрузок получаем сообщение: "Specifying boot ID has no effect, no persistent journal was found"

Исправляем ситуацию так: 
В файле /etc/systemd/journald.conf  параметр  Storage выставляем в persistent - Storage=persistent
И перезапускаем сервис командой:
systemctl restart systemd-journald

Должно сработать:
journalctl -k -b -0 - текущая загрузка
journalctl -k -b -1 - предыдущая
journalctl -k -b -2 - предыдущая предыдущая
journalctl -k -b -n - и т. д.

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Как проверить драйвер сетевой карты и версию прошивки на Linux

 ethtool -i eth0
 =-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
затирает содержимое файла ntp

 sudo sh -c "echo -n ' ' > /etc/ntp.conf "
 
   =-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   добавить в саппорт
 !!!! как посветить сетевую карту !!!!
sudo ethtool -p net0 1500
 
 
    =-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
настройка региона 

 sudo dpkg-reconfigure locales

    =-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    показывает серийный номер сетевойкарты 
    

 sudo lshw -class network
 
  Ниже приведены некоторые из поддерживаемых классов:

- system: аппаратное обеспечение и свойства системы
- memory: память системы
- processor: процессор
- display: графический адаптер (видеокарта)
- network: сетевой адаптер
- storage: устройства хранения данных (например, жесткие диски, SSD)

 
 
 
     =-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
 
 Когда вы устанавливаете пакет с помощью команды apt-get или apt (или пакетов DEB в центре программного обеспечения), менеджер пакетов apt загружает пакет и его зависимости в формате .deb и сохраняет его в папке /var/cache/apt/archive

─ /var/cache/apt/archives

sudo apt-get clean

можно скачать дял дальнейшей установки
sudo apt-get install --download-only gcc-10
паекты будут находиться в  папке ─ /var/cache/apt/archives

The following additional packages will be installed:
  cpp-10 gcc-10-base gcc-11-base gcc-13-base libasan6 libatomic1 libcc1-0 libgcc-10-dev libgcc-s1 libgomp1 libitm1 liblsan0 libquadmath0 libtsan0 libubsan1
Suggested packages:
  gcc-10-locales gcc-10-multilib gcc-10-doc libgcc-s1-dbg libgomp1-dbg libitm1-dbg libatomic1-dbg libasan6-dbg liblsan0-dbg libtsan0-dbg libubsan1-dbg libquadmath0-dbg


				     =-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


3. ОЧИСТКА ПАКЕТОВ
Пакеты программного обеспечения одно из самых слабых мест для засорения системы. Если вы устанавливали много приложений, скорее всего, они потянули за собой большое количество зависимостей, которые после удаления этих приложений не представляют никакой пользы. Поэтому очистка Ubuntu обязательно должна включать удаление ненужных пакетов. Вот несколько команд выполняющих очистку системы:

Удалить неиспользуемые пакеты из кэша

 sudo apt autoclean

Очистка кэша в Ubuntu, утилиты apt:

 sudo apt clean

Удаление ненужных зависимостей:

 sudo apt autoremove

Вообще хорошей практикой будет удалять зависимости сразу при удалении приложения:

 sudo apt autoremove приложение
 
 
 =-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
службы которые можно запустить
 
 ls /etc/init.d
 
 
 =-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 
 Принудительная перезагрузка Linux, когда команда reboot не работает

echo s > /proc/sysrq-trigger # emergency sync of the block devices
echo u > /proc/sysrq-trigger # mount readonly of all filesystems
echo s > /proc/sysrq-trigger # sync
echo b > /proc/sysrq-trigger # force an immediate boot; you can also use o for poweroff.

 =-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Рабта с процессами 



Как найти и убить зомби-процессы
Чтобы убить зомби-процесс, сначала найдите егно.

Используйте приведенные ниже команды для выявления зомби-процессов.

$ ps aux | egrep "Z|defunct"
Z, используемый в колонке STAT, и/или [defunct], используемый в последней колонке вывода, идентифицирует зомби-процесс.

На самом деле, вы не можете убить зомби-процессы, так как они уже мертвы.

Все, что вы можете сделать, это уведомить его родительский процесс, чтобы он мог снова попытаться прочитать статус дочернего процесса, который теперь стал зомби-процессом, и, в конце концов, мертвый процесс будет удален из таблицы процессов.

Используйте следующую команду, чтобы узнать ID родительского процесса.

$ ps -o ppid= <PID дочернего процесса>.
 ps -o ppid= 291159
Как только вы узнаете ID родительского процесса зомби, отправьте SIGCHLD родительскому процессу.

esermyagin@g10:~$ ps -o ppid= 291159
 291140

$ kill -s SIGCHLD <Родительский PID>.
Если это не помогло удалить зомби-процесс из таблицы процессов, вам нужно перезапустить или убить его родительский процесс.

Чтобы убить родительский процесс зомби, используйте следующий код.

$ kill -9 <Родительский PID>

 =-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Переменные окружения 
Команда env используется для вывода списка переменных окружения, которые доступны в текущей сессии терминала. Это могут быть переменные, установленные системой по умолчанию, а также переменные, установленные пользователем или приложением.

Команда export используется для установки переменных окружения. Когда вы устанавливаете переменную с помощью export, она становится доступной для всех процессов, запущенных из текущей сессии терминала, а также для всех дочерних процессов, запущенных из этих процессов.

Таким образом, env позволяет просмотреть текущие переменные окружения, а export позволяет установить новые переменные окружения или изменить существующие.

printenv    это команда, которая выводит на экран список всех переменных среды, установленных в текущем сеансе shell.



=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Команды who и w и whoami в Linux используются для вывода информации о текущих пользователях, которые вошли в систему.

Команда who выводит список всех пользователей, которые вошли в систему, включая их имя пользователя, терминал, с которого они вошли, дату и время входа в систему.

Команда w также выводит информацию о текущих пользователях, но в более подробном формате. Она показывает имя пользователя, терминал, с которого они вошли, дату и время входа в систему, а также текущую нагрузку на систему и время, которое пользователь провел в системе.

Таким образом, who и w выполняют похожую функцию, но w предоставляет более подробную информацию о текущих пользователях и нагрузке на систему.

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
что значит Read-only file system в ubuntu
"Read-only file system" - это сообщение об ошибке, которое означает, что файловая система, на которой вы пытаетесь выполнить операцию записи, доступна только для чтения. Это может произойти по нескольким причинам:

1. Файловая система была смонтирована в режиме "только для чтения". Это может произойти, если файловая система была повреждена или если на нее было наложено ограничение на запись.

2. Файловая система находится в состоянии ошибки. Это может произойти, если файловая система была повреждена или если на нее было наложено ограничение на запись.

3. Файловая система находится на устройстве, которое не поддерживает запись. Например, это может быть CD-ROM или DVD-ROM.

Чтобы исправить эту ошибку, вам нужно определить причину и принять соответствующие меры. Если файловая система была смонтирована в режиме "только для чтения", вы можете попытаться смонтировать ее в режиме чтения и записи. Если файловая система находится в состоянии ошибки, вам может потребоваться выполнить проверку файловой системы и восстановление. Если файловая система находится на устройстве, которое не поддерживает запись, вам нужно использовать другое устройство для записи данных.

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
коментирование строки 

cat -n /etc/rc.local

cat -n выводит пронумерованые строки 

выбираем нужную в данном случае 12 строку и комнтериуем ее 

sudo sed -i '12s/^/#/' /etc/rc.local

sudo sed -i '10s/^/#/' /etc/rc.local

			=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

sed -n '20,25p' lines.txt

раскоментирование строки 

 number_line=$(cat -n  /etc/rc.local | grep /home/g10/.G10.boot | awk '{print $1}');sed -i '$numder_line s/^#//' /etc/rc.local


sudo sed -i '13d' ./interfaces  удаляет определнную строку 
sudo sed -i '25,27d' ./interfaces удаляет диапазон строк 

https://losst.ru/komanda-sed-linux



sudo sed -i 's/auto net0/auto net4/' /etc/network/interfaces;
sudo sed -i 's/iface net0 inet static/iface net4 inet static/' /etc/network/interfaces

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
вводим текст в конец файла  

sudo tee -a ./interfaces <<EOF				

>тело текста (auto net0
> iface net0 inet static
> address 192.168.150.106
> netmask 24
> gateway 192.168.160.249)

>EOF выйдет из ввода команды 

			=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
вводим строку в конец файла 

 echo '1' | sudo tee -a /etc/network/interfaces	
 
 
 
 
=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
Как узнать файловую систему?

Для того, чтобы определить в какую файловую систему отформатирован раздел, существует несколько решений:

df -Th | grep "^/dev"
Lля просмотра файловой системы только на физических дисках.

fsck -N /dev/nvme0n1p6
Если раздел ещё не примонтирован, а вам надо узнать его файловую систему.

lsblk -f

mount | grep "^/dev"

blkid /dev/nvme0n1p6
часто используется для просмотра UUID, однако может показать и файловую систему.

sudo file -sL /dev/nvme0n1p6





sudo cat /etc/fstab 
 - монтируемые разделы
sudo blkid
 - привязка разделов к реальным железкам
sudo lshw -C disk -businfo
 - привязка дисков к разъёмам

показывает рельно занятые sata порты
lsscsi -H
dmesg | grep 'SATA link down' 
 sudo dmidecode --type connector 
 
 
 
 
 
 
Как смонтировать только что добавленный жесткий диск ubuntu
Чтобы смонтировать только что добавленный жесткий диск в Ubuntu, нужно выполнить следующие шаги:

1. Откройте терминал и введите команду sudo fdisk -l, чтобы узнать идентификатор нового жесткого диска. Обычно он будет иметь формат /dev/sdX, где X - буква, обозначающая новый диск.

2. Создайте точку монтирования для нового диска, например, /mnt/newdisk, с помощью команды sudo mkdir /mnt/newdisk.

3. Смонтируйте новый диск в созданную точку монтирования с помощью команды sudo mount /dev/sdX /mnt/newdisk, где X - буква, обозначающая новый диск.

4. Проверьте, что диск успешно смонтирован, выполнив команду df -h. Вы должны увидеть новый диск в списке смонтированных устройств.

Чтобы автоматически монтировать новый диск при каждом запуске системы, нужно добавить запись в файл /etc/fstab. Для этого выполните следующие шаги:

1. Откройте файл /etc/fstab в текстовом редакторе с правами администратора, например, с помощью команды sudo nano /etc/fstab.

2. Добавьте следующую строку в конец файла, заменив X на букву, обозначающую новый диск, и mount_point на точку монтирования, которую вы создали ранее:

/dev/sdX    mount_point    ext4    defaults    0    2


3. Сохраните изменения и закройте файл.

После перезагрузки системы новый диск будет автоматически смонтирован в указанную точку монтирования. 
 
 
 Для монтирования нового диска в корневую директорию в Ubuntu, вам нужно выполнить следующие шаги:

1. Подключите новый диск к вашей системе.
2. Откройте терминал и выполните команду sudo fdisk -l, чтобы узнать идентификатор нового диска. Обычно это будет /dev/sdb, /dev/sdc и т.д.
3. Создайте точку монтирования для нового диска, выполнив команду sudo mkdir /mnt/newdisk.
4. Смонтируйте новый диск в созданную точку монтирования, выполнив команду sudo mount /dev/sdb /mnt/newdisk, заменив /dev/sdb на идентификатор вашего нового диска.
5. Проверьте, что диск успешно примонтирован, выполнив команду df -h.

Обратите внимание, что при перезагрузке системы точка монтирования исчезнет, и диск не будет автоматически монтироваться. Чтобы автоматически монтировать диск при загрузке системы, вам нужно добавить запись в файл /etc/fstab.
lsblk -f



Для изменения файловой системы диска на ext4 в Ubuntu, вам нужно выполнить следующие шаги:

1. Убедитесь, что диск, который вы хотите изменить, не смонтирован. Если диск смонтирован, отмонтируйте его с помощью команды umount.

2. Запустите команду sudo mkfs.ext4 /dev/sdX, где /dev/sdX - это идентификатор диска, который вы хотите изменить. Например, если вы хотите изменить файловую систему диска /dev/sdb, то команда будет выглядеть так: sudo mkfs.ext4 /dev/sdb.

3. Подтвердите изменение файловой системы, нажав клавишу "y" на запрос о подтверждении.

4. Дождитесь завершения процесса форматирования диска.

5. После завершения форматирования диска вы можете смонтировать его обратно в систему с помощью команды mount.

Обратите внимание, что при изменении файловой системы диска все данные на нем будут удалены, поэтому перед выполнением этой операции необходимо создать резервную копию важных данных.
 
 
 
 
 
 
 
https://itproffi.ru/komanda-fdisk-upravleniya-razdelami-zhyostkogo-diska/ 
 
 
 
 
Для удаления существующих разделов диска, форматирования и создания нового раздела в Ubuntu вы можете воспользоваться утилитой fdisk. Пожалуйста, обратите внимание, что эти действия могут привести к потере данных на диске, поэтому убедитесь, что у вас есть резервное копирование всех важных данных, прежде чем продолжить.

Вот пошаговая инструкция:

1. Откройте терминал:
   Откройте терминал на вашем компьютере Ubuntu.

2. Запустите утилиту fdisk:
   Запустите утилиту fdisk для управления разделами диска:
   ```bash
   sudo fdisk /dev/sdX
   ```
   Замените sdX на букву вашего диска, например, sda, sdb, и т.д. Будьте осторожны при выборе диска, чтобы не удалить или повредить важные данные.

3. Удалите существующие разделы:
   - Нажмите d для удаления раздела.
   - Если у вас несколько разделов, повторите этот шаг для каждого раздела.

4. Создайте новый раздел:
   - Нажмите n для создания нового раздела.
   - Выберите тип раздела (по умолчанию выбирайте Primary раздел) и размер раздела.
   - После создания раздела, снова нажмите p для просмотра вашего нового раздела.

5. Форматируйте новый раздел:
   - Нажмите w для записи изменений на диск.
   - После этого можно сразу форматировать раздел, например, для файловой системы ext4:
     ```bash
     sudo mkfs.ext4 /dev/sdX1
     ```
     Замените sdX1 соответствующим новым разделом, например, sda1.

6. Создайте точку монтирования:
   - Создайте каталог, который вы будете использовать в качестве точки монтирования нового раздела:
     ```bash
     sudo mkdir /mnt/new_partition
     ```

7. Смонтируйте новый раздел:
   - Смонтируйте новый раздел в созданную ранее точку монтирования:
     ```bash
     sudo mount /dev/sdX1 /mnt/new_partition
     ```

Теперь у вас должен быть новый раздел, отформатированный и готовый к использованию на вашей системе Ubuntu. 
 
 
  			=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
 SCREEN в терминале:
screen - запуск
Ctrl + a - с - новое окно
Ctrl + a - w - список окон
Ctrl + a и S - разделить по горизонтали
Ctrl + a и | - разделить по вертикали
Ctrl + a и Tab - переключение между разделителями
Ctr + a и c - запустить терминал в разделителях
Ctrl+a и k - завершить работу окна
screen -ls - просмотр запущенных сессий
"Ctrl-a" "H" - регистрация сеанса, логирование

  			=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=



Чтобы сделать вывод команды исполняемым, можно использовать команду eval. Она позволяет выполнить команду, переданную в виде строки.

В вашем случае, чтобы сделать вывод команды cat ./open_ports | grep 3599 исполняемым, можно использовать следующую команду:

eval $(cat ./open_ports | grep 3599)


Эта команда выполнит вывод команды cat ./open_ports | grep 3599 и передаст результат в команду eval, которая выполнит его как команду.

Обратите внимание, что использование команды eval может быть опасным, если в выводе команды содержатся нежелательные символы или команды. Поэтому перед использованием команды eval следует убедиться, что вывод команды безопасен для выполнения.


  			=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


В bash можно использовать оператор && для выполнения команды, если предыдущая команда завершилась успешно, и оператор || для выполнения команды, если предыдущая команда завершилась неудачно. Это позволяет создавать конструкции if-else в одной строке.

Например, следующая команда выполнит команду echo "Success" если команда ls /tmp завершится успешно, и выполнит команду echo "Failure" в противном случае:

ls /tmp && echo "Success" || echo "Failure"


Вы можете заменить команду ls /tmp на любую другую команду, которую вы хотите проверить на успех или неудачу.

  			=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

"$0" одна из специальных переменных, которые предлагает Bash, и используется для печати имени файла скрипта, который на данный момент выполняется.

Есть два варианта использования этой переменной:

узнать имя используемой оболочки;
напечатать имя выполняющегося скрипта.


=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


Команда cut в Linux используется для извлечения определенных секций текста из файла или вывода команды. Она может использоваться для обрезки строк, разделенных определенным разделителем, или для извлечения определенных символов из каждой строки.

Основной синтаксис команды cut выглядит следующим образом:

cut [OPTIONS] [FILE]


Здесь OPTIONS - это опции команды, которые определяют, какие секции текста нужно извлечь, а FILE - это имя файла, из которого нужно извлечь текст. Если FILE не указан, то cut будет использовать стандартный ввод.

Основные опции команды cut:

- -c - извлекает определенные символы из каждой строки. Например, cut -c 1-5 file.txt извлечет первые пять символов из каждой строки файла file.txt.
- -f - извлекает определенные поля из каждой строки, разделенной определенным разделителем. Например, cut -f 1,3 -d "," file.csv извлечет первое и третье поля из каждой строки файла file.csv, разделенной запятыми.
- -d - определяет разделитель полей для опции -f. Например, cut -f 1,3 -d ":" file.txt извлечет первое и третье поля из каждой строки файла file.txt, разделенной двоеточием.

Кроме того, команда cut поддерживает множество других опций, таких как -b для извлечения байтов, -n для отключения разбиения строк и т.д.



=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
как сделать такую ссылку 
g10@g10:/var/lib$ ls -hl jeson
lrwxrwxrwx 1 root root 17 фев 21 22:28 jeson -> /home/user/jeson
н
Чтобы создать символическую ссылку в Linux, используйте команду ln. Для создания символической ссылки на каталог /home/user/jeson в каталоге /var/lib выполните следующую команду:
ln -s /home/user/jeson /var/lib/jeson
ln -s 

Эта команда создаст символическую ссылку с именем jeson в каталоге /var/lib, которая будет указывать на каталог /home/user/jeson. При этом, если вы выполните команду ls -hl /var/lib/jeson, то увидите, что она указывает на /home/user/jeson.


=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

source "$(dirname $0)/repo.sh"
Эта команда загружает и выполняет скрипт "repo.sh", который находится в той же директории, что и текущий скрипт. 

$(dirname $0) возвращает путь к директории, в которой находится текущий скрипт. 

/repo.sh добавляет к этому пути имя файла скрипта, который нужно загрузить и выполнить. 
source выполняет скрипт в текущем контексте оболочки, что позволяет использовать переменные и функции, определенные в этом скрипте, в текущем скрипте. 
Таким образом, эта команда загружает и выполняет скрипт "repo.sh", который, вероятно, содержит определения функций и переменных, необходимых для работы текущего скрипта.

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

make-утилита предназначенная для автоматизации преобразования файлов из одной формы в другую. Правила преобразования задаются в скрипте с именем Makefile, который должен находиться в корне рабочей директории проекта. Сам скрипт состоит из набора правил, которые в свою очередь описываются:
https://habr.com/ru/articles/211751/


1) целями (то, что данное правило делает);
2) реквизитами (то, что необходимо для выполнения правила и получения целей);
3) командами (выполняющими данные преобразования).

В общем виде синтаксис makefile можно представить так:

# Индентация осуществляется исключительно при помощи символов табуляции,
# каждой команде должен предшествовать отступ
<цели>: <реквизиты>
	<команда #1>
	...
	<команда #n>
=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

копирование открытого ключа 
ssh-copy-id aptly@192.168.55.245 с сервера для песорольного доступа к учетной записи aptly
=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
как исправить ошибку 
Err:9 https://pkg.jenkins.io/debian-stable binary/ Release.gpg       
  The following signatures couldn't be verified because the public key is not available: NO_PUBKEY 5BA31D57EF5975CA
 
 скопировать с сервера keyserver.ubuntu.com
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5BA31D57EF5975CA


sudo apt-key export 5BA31D57EF5975CA | sudo apt-key add -


В Linux, capabilities (возможности) представляют собой механизм, который позволяет уточнять привилегии, необходимые для выполнения определенных операций, в отличие от классической модели привилегий в Unix, которая разделяет процессы на привилегированные и непривилегированные.

Вместо того, чтобы предоставлять процессу полный доступ от имени суперпользователя (root), capabilities позволяют ограничивать привилегии конкретно для выполнения определенных операций, таких как управление сетью, монтирование файловых систем, администрирование процессов и другие. Это помогает повысить безопасность системы, ограничивая возможности процессов даже при наличии специфических привилегий.

Примеры capabilities включают CAP_NET_ADMIN для управления сетью, CAP_SYS_ADMIN для администрирования системы и другие. Когда процессу назначается определенная возможность, он может выполнять только операции, оговоренные этой возможностью, не обладая полными привилегиями суперпользователя.

Использование capabilities позволяет более точно контролировать привилегии процессов, сохраняя при этом уровень безопасности системы.



 getcap /usr/bin/ip
/usr/bin/ip cap_net_admin=ep


Результат команды getcap /usr/bin/ip указывает на то, что установленная возможность (capability) для файла /usr/bin/ip - это cap_net_admin=ep. Значения cap_net_admin и ep представляют собой соответственно возможность CAP_NET_ADMIN и флаг ep.

- CAP_NET_ADMIN: Эта возможность предоставляет расширенный доступ к сетевым настройкам и может использоваться для выполнения различных операций с сетевыми интерфейсами без привилегий суперпользователя (root).

- Флаг ep: e означает, что возможность применена к файлу или к каталогу. p означает, что возможность сохраняется после исполнения файла.

Таким образом, у файла /usr/bin/ip установлена возможность CAP_NET_ADMIN с флагами e и p, что позволяет этому файлу использовать возможности сетевой администрации без необходимости запуска от имени суперпользователя и сохранять эти права после выполнения.




Команда getcap в Linux используется для получения информации о назначенных capabilities (возможностях) для исполняемых файлов. Кроме cap_net_admin, которая отвечает за расширенный доступ к сетевым настройкам, существует ряд других возможных capabilities, которые могут быть назначены файлам для предоставления различных привилегий. Некоторые из наиболее распространенных capabilities в Linux включают:

1. CAP_SYS_ADMIN: Позволяет процессу выполнять различные административные задачи в системе.
2. CAP_SYS_PTRACE: Дает возможность процессу отлаживать другие процессы и получать доступ к их памяти.
3. CAP_DAC_OVERRIDE: Позволяет процессу игнорировать ограничения доступа к файлам и каталогам в системе.
4. CAP_SETUID: Разрешает процессу изменять свой идентификатор пользователя без необходимости иметь привилегии суперпользователя.
5. CAP_NET_RAW: Позволяет процессу отправлять и принимать "сырые" пакеты сетевого уровня.

Вы можете использовать команду getcap /путь_к_файлу для просмотра всех назначенных capabilities для конкретного файла и узнать, какие возможности имеются помимо cap_net_admin.


=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Управление модулями



lsmod- вывод всех загруженных модулей в виде таблицы.

modinfo- вывод информации о модуле: файл модуля, краткое описание, авторы, лицензия, параметры.
modinfo ip_tables 

modprobe утилита для загрузки и выгрузки модулей.
В большинстве случаев загрузка модулей осуществляется одной из следующих команд:

sudo modprobe название_модуля
sudo insmod название_модуля
При загрузке модуля ему можно указывать определенные параметры:

sudo modprobe название_модуля параметр=значение
или

sudo insmod название_модуля параметр=значение
Список параметров можно узнать выполнив

modinfo название_модуля
Выгружаются модули командами

sudo rmmod название_модуля
sudo modprobe -r название_модуля

Файлы конфигурации
Для того чтобы определенные модули загружались/не загружались во время старта системы их можно прописать в файл /etc/modules . Каждый модуль должен быть записан в отдельной строке. Строки начинающиеся со слова blacklist запрещают загрузку модуля.

Кроме /etc/modules существует директория /etc/modprobe.d. В ней лежат отдельные конфигурационные файлы аналогичные по сути /etc/modules.

=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

